#include <vector>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <string>
#include <cmath>

std::vector<std::vector<std::vector<unsigned char>>> expandKey(std::string key);
std::vector<std::vector<std::vector<unsigned char>>> getMessageBlocks(std::string message);
std::string decrypt(std::vector<std::vector<std::vector<unsigned char>>> keyRounds, std::string cipherText);
std::string encrypt(std::vector<std::vector<std::vector<unsigned char>>> key, std::vector<std::vector<std::vector<unsigned char>>> message);

// Bunch of lookup tables to make life easier
int rcon[10] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36};

//encryption and decryption
unsigned char Sbox[256] = {0x63 ,0x7c ,0x77 ,0x7b ,0xf2 ,0x6b ,0x6f ,0xc5 ,0x30 ,0x01 ,0x67 ,0x2b ,0xfe ,0xd7 ,0xab ,0x76
                            ,0xca ,0x82 ,0xc9 ,0x7d ,0xfa ,0x59 ,0x47 ,0xf0 ,0xad ,0xd4 ,0xa2 ,0xaf ,0x9c ,0xa4 ,0x72 ,0xc0
                            ,0xb7 ,0xfd ,0x93 ,0x26 ,0x36 ,0x3f ,0xf7 ,0xcc ,0x34 ,0xa5 ,0xe5 ,0xf1 ,0x71 ,0xd8 ,0x31 ,0x15
                            ,0x04 ,0xc7 ,0x23 ,0xc3 ,0x18 ,0x96 ,0x05 ,0x9a ,0x07 ,0x12 ,0x80 ,0xe2 ,0xeb ,0x27 ,0xb2 ,0x75
                            ,0x09 ,0x83 ,0x2c ,0x1a ,0x1b ,0x6e ,0x5a ,0xa0 ,0x52 ,0x3b ,0xd6 ,0xb3 ,0x29 ,0xe3 ,0x2f ,0x84
                            ,0x53 ,0xd1 ,0x00 ,0xed ,0x20 ,0xfc ,0xb1 ,0x5b ,0x6a ,0xcb ,0xbe ,0x39 ,0x4a ,0x4c ,0x58 ,0xcf
                            ,0xd0 ,0xef ,0xaa ,0xfb ,0x43 ,0x4d ,0x33 ,0x85 ,0x45 ,0xf9 ,0x02 ,0x7f ,0x50 ,0x3c ,0x9f ,0xa8
                            ,0x51 ,0xa3 ,0x40 ,0x8f ,0x92 ,0x9d ,0x38 ,0xf5 ,0xbc ,0xb6 ,0xda ,0x21 ,0x10 ,0xff ,0xf3 ,0xd2
                            ,0xcd ,0x0c ,0x13 ,0xec ,0x5f ,0x97 ,0x44 ,0x17 ,0xc4 ,0xa7 ,0x7e ,0x3d ,0x64 ,0x5d ,0x19 ,0x73
                            ,0x60 ,0x81 ,0x4f ,0xdc ,0x22 ,0x2a ,0x90 ,0x88 ,0x46 ,0xee ,0xb8 ,0x14 ,0xde ,0x5e ,0x0b ,0xdb
                            ,0xe0 ,0x32 ,0x3a ,0x0a ,0x49 ,0x06 ,0x24 ,0x5c ,0xc2 ,0xd3 ,0xac ,0x62 ,0x91 ,0x95 ,0xe4 ,0x79
                            ,0xe7 ,0xc8 ,0x37 ,0x6d ,0x8d ,0xd5 ,0x4e ,0xa9 ,0x6c ,0x56 ,0xf4 ,0xea ,0x65 ,0x7a ,0xae ,0x08
                            ,0xba ,0x78 ,0x25 ,0x2e ,0x1c ,0xa6 ,0xb4 ,0xc6 ,0xe8 ,0xdd ,0x74 ,0x1f ,0x4b ,0xbd ,0x8b ,0x8a
                            ,0x70 ,0x3e ,0xb5 ,0x66 ,0x48 ,0x03 ,0xf6 ,0x0e ,0x61 ,0x35 ,0x57 ,0xb9 ,0x86 ,0xc1 ,0x1d ,0x9e
                            ,0xe1 ,0xf8 ,0x98 ,0x11 ,0x69 ,0xd9 ,0x8e ,0x94 ,0x9b ,0x1e ,0x87 ,0xe9 ,0xce ,0x55 ,0x28 ,0xdf
                            ,0x8c ,0xa1 ,0x89 ,0x0d ,0xbf ,0xe6 ,0x42 ,0x68 ,0x41 ,0x99 ,0x2d ,0x0f ,0xb0 ,0x54 ,0xbb ,0x16};

//encryption
unsigned char mul2[256] = {0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
                            0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
                            0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
                            0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
                            0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
                            0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
                            0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
                            0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
                            0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
                            0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
                            0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
                            0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
                            0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
                            0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
                            0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
                            0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5};

//encryption
unsigned char mul3[256] = {0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
                            0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
                            0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
                            0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
                            0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
                            0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
                            0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
                            0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
                            0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
                            0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
                            0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
                            0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
                            0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
                            0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
                            0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
                            0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a};

//decryption
unsigned char mul9[256] = {0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
                            0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
                            0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
                            0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
                            0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
                            0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
                            0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
                            0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
                            0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
                            0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
                            0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
                            0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
                            0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
                            0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
                            0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
                            0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46};

//decryption
unsigned char mul11[256] = {0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
                            0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
                            0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
                            0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
                            0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
                            0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
                            0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
                            0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
                            0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
                            0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
                            0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
                            0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
                            0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
                            0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
                            0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
                            0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3};

//decryption 
unsigned char mul13[256] = {0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
                            0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
                            0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
                            0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
                            0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
                            0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
                            0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
                            0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
                            0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
                            0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
                            0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
                            0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
                            0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
                            0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
                            0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
                            0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97};

//decryption
unsigned char mul14[256] = {0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
                            0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
                            0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
                            0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
                            0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
                            0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
                            0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
                            0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
                            0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
                            0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
                            0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
                            0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
                            0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
                            0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
                            0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
                            0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d};

//Function that generates roundKeys
std::vector<std::vector<std::vector<unsigned char>>> expandKey(std::string originalKey) {
    //Check if the key is correct size
    //Keys smaller than 16 bytes are allowed, but empty byte values are replaced with 0x00
    if(originalKey.length() > 16) {
        std::cout << "Maximum key size is 16 characters" << std::endl;
        std::cout << "Try different key: " << std::endl;
        std::getline(std::cin, originalKey);
    }

    std::vector<std::vector<std::vector<unsigned char>>> roundKeys(11, std::vector<std::vector<unsigned char>>(4, std::vector<unsigned char>(4)));
    char tmp[16] = {0};
    strncpy(tmp, originalKey.c_str(), originalKey.length());

    //Assign first round keys
    for(int i = 0, y = 0; i < 4; i++) for(int ii = 0; ii < 4; ii++, y++) roundKeys[0][i][ii] = tmp[y];

    //Assign the rest of the rounds
    for(int i = 1; i < roundKeys.size(); i++) {
        // These integer arrays represent rows
        int first[4], second[4], third[4], fourth[4];

        // 1) Shift the fourth array to left
        for(int ii = 0; ii < 4; ii++) {
            first[ii] = int(roundKeys[i-1][0][ii]);
            second[ii] = int(roundKeys[i-1][1][ii]);
            third[ii] = int(roundKeys[i-1][2][ii]);

            if(ii + 1 == 4) fourth[ii] = int(roundKeys[i-1][3][0]);
            else fourth[ii] = int(roundKeys[i-1][3][ii + 1]);
            
        }

        // 2) S-Box the fourth array
        for(int ii = 0; ii < 4; ii++) fourth[ii] = Sbox[fourth[ii]];

        // 3) Add Rcon to fourth array
        fourth[0] = fourth[0]^rcon[i-1];

        // 4) Get roundKey
        for(int ii = 0; ii < 4; ii++) {
            roundKeys[i][0][ii] = fourth[ii]^first[ii];
            roundKeys[i][1][ii] = roundKeys[i][0][ii]^second[ii];
            roundKeys[i][2][ii] = roundKeys[i][1][ii]^third[ii];
            roundKeys[i][3][ii] = roundKeys[i][2][ii]^roundKeys[i-1][3][ii];
        }
    }

    return roundKeys;
}

//Function that puts user entered message into 16byte blocks
std::vector<std::vector<std::vector<unsigned char>>> getMessageBlocks(std::string message) {
    char tmp[message.length()];
    strncpy(tmp, message.c_str(), message.length());

    int remnant = message.length()%16;
    std::vector<std::vector<std::vector<unsigned char>>> blockMes((message.length() - remnant)/16 + 1, std::vector<std::vector<unsigned char>>(4, std::vector<unsigned char>(4)));

    for(int i = 0, y = 0; i < blockMes.size(); i++) {
        for(int ii = 0; ii < 4; ii++) {
            for(int iii = 0; iii < 4; iii++, y++) {

                if(y < sizeof(tmp) / sizeof(*tmp)) blockMes[i][ii][iii] = tmp[y];
                else blockMes[i][ii][iii] = 0;
                
            }
        }
    }

    return blockMes;
}

//Function that generates IV
std::vector<std::vector<unsigned char>> generateIV() {
    std::vector<std::vector<unsigned char>> IV(4, std::vector<unsigned char>(4));
    srand(time(0));
    for(int i = 0; i < 4; i++) for(int ii = 0; ii < 4; ii++) IV[i][ii] = rand() % 256;

    return IV;
}
//base64
char base64Set[64] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
                    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
                    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
                    'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};

//Function that converts decimal value to binary array
std::vector<int> decToBin(int dec, int bits) {
    int x = 0;
    std::vector<int> binBuffer(bits);
    std::vector<int> bins(bits);

    for(x = 0; dec > 0; x++) {
        binBuffer[x] = dec%2;
        dec /= 2;
    }

    int dif = bits - x;
    int y = 0;
    for(x = x -1; x>=0; x--, y++) bins[y] = binBuffer[x];

    if(dif != 0) {

        for(int x = bits - 1; x >= dif; x--) bins[x] = bins[x - dif];

        for(int x = 0; x < dif; x++) bins[x] = 0;

    }

    return bins;
}

//Function that converts binary value to decimal
int binToDec(int *bins, int bits) { 
    int dec = 0;
    int exponent = bits - 1;

    for(int i = 0; i < sizeof(bins) && exponent >= 0; i++, exponent--) if(bins[i] == 1) dec += pow(2, exponent);

    return dec;
}

//Function that encodes decimal array with base64
std::string encode(std::vector<unsigned int> decArr) {

    std::string encodedMes;
    
    //Put binary values into one array
    int bins[decArr.size()*8];
    for(int i = 0, y = 0; i < decArr.size(); i++) {

        std::vector<int> tmp = decToBin(decArr[i], 8);
        for(int x : tmp) bins[y] = x, y++;
        
    }

    int remnant = (sizeof(bins) / sizeof(*bins))%6;

    //Check if binary array fits into 6 bits and if needed do padding
    if(remnant != 0) {
        int base64Bins[(sizeof(bins) / sizeof(*bins) - remnant) / 6 + 1][6];

        for(int i = 0; i < sizeof(base64Bins) / sizeof(*base64Bins); i++) for(int ii = 0; ii < 6; ii++) base64Bins[i][ii] = 0;

        for(int i = 0, y = 0; i < sizeof(base64Bins) / sizeof(*base64Bins); i++) {

            for(int ii = 0; ii < 6; ii++, y++){ 

                if(y < sizeof(bins) / sizeof(*bins)) base64Bins[i][ii] = bins[y]; 
                else base64Bins[i][ii] = 0;
            }
            encodedMes += base64Set[binToDec(base64Bins[i], 6)];
        }

        if(6 - remnant == 2) encodedMes += "=";
        else if(6- remnant == 4) encodedMes += "==";
    }

    else {
        int base64Bins[(sizeof(bins) / sizeof(*bins) - remnant) / 6][6];

        for(int i = 0; i < sizeof(base64Bins) / sizeof(*base64Bins); i++) for(int ii = 0; ii < 6; ii++) base64Bins[i][ii] = 0;

        for(int i = 0, y = 0; i < sizeof(base64Bins) / sizeof(*base64Bins); i++) {
            for(int ii = 0; ii < 6; ii++, y++) base64Bins[i][ii] = bins[y];
            encodedMes += base64Set[binToDec(base64Bins[i], 6)];
        }
    }

    return encodedMes;
}

//Function that decodes the message into decimal values
std::vector<unsigned char> decode(std::string encodedMessage) {
    
    //Put message into char array
    char chMes[encodedMessage.length()];
    strcpy(chMes, encodedMessage.c_str());


    int binZerosFromEnd = 0;
    int sizeReducer;

    //Check for any paddings
    if(chMes[encodedMessage.length()-1] == '=' && chMes[encodedMessage.length()-2] == '=') binZerosFromEnd = 4, sizeReducer = 2;
    else if(chMes[encodedMessage.length()-1] == '=' && chMes[encodedMessage.length()-2] != '=') binZerosFromEnd = 2, sizeReducer = 1;
    else binZerosFromEnd = 0, sizeReducer = 0;


    std::vector<int> decs(encodedMessage.length() - sizeReducer);
    int lastIndex;

    for(lastIndex = 0; chMes[lastIndex] != '=' && lastIndex < encodedMessage.size() - sizeReducer; lastIndex++) {
        int dec;
        for(dec = 0; base64Set[dec] != chMes[lastIndex]; dec++);
        decs[lastIndex] = dec;
    }
    
    int bins[decs.size()*6 - binZerosFromEnd];
    for(int i = 0; i < sizeof(bins) / sizeof(*bins); i++) bins[i] = 0;

    for(int i = 0, y = 0; i < decs.size(); i++) {
        std::vector<int> bin = decToBin(decs[i], 6);
        for(int ii = 0; ii < 6 && y < sizeof(bins) / sizeof(*bins); ii++) bins[y] = bin[ii], y++;
    }

    std::vector<unsigned char> bitDecs(sizeof(bins) / sizeof(*bins) / 8);
    for(int i = 0, y = 0; i < sizeof(bins) / sizeof(*bins) / 8; i++) {
        int tmp[8];
        for(int ii = 0; ii < 8; ii++, y++) tmp[ii] = bins[y];

        bitDecs[i] = binToDec(tmp, 8);
    }

    return bitDecs;

}

//Function that encrypts messageblocks with roundKeys and return cipherText
std::string encrypt(std::vector<std::vector<std::vector<unsigned char>>> keyRounds, std::vector<std::vector<std::vector<unsigned char>>> messageBlocks) {
    
    std::string cipherText;
    std::vector<std::vector<unsigned char>> IV = generateIV();
    std::vector<unsigned int> decCipherBlock(messageBlocks.size()*16 + 18);
    int decIndex = 0;
    for(int blockIndex = 0; blockIndex < messageBlocks.size(); blockIndex++) {

        // 1) CBC initialisation
        for(int i = 0; i < 4; i++) for(int ii = 0; ii < 4; ii++) {
            if(blockIndex == 0) messageBlocks[blockIndex][i][ii] ^= IV[i][ii];
            else messageBlocks[blockIndex][i][ii] ^= messageBlocks[blockIndex - 1][i][ii];
        }

        // 2) Initialisation XoRing messageblock with roundkey 0
        for(int i = 0; i < 4; i++) {
            for(int ii = 0; ii < 4; ii++) messageBlocks[blockIndex][i][ii] ^= keyRounds[0][i][ii];
        }

        // 3) Repeat the following process for 9 times
        for(int round = 1; round < 10; round++) {

            // 3.1) Get subbytes from S-box
            for(int i = 0; i < 4; i++) {
                for(int ii = 0; ii < 4; ii++) messageBlocks[blockIndex][i][ii] = Sbox[messageBlocks[blockIndex][i][ii]];
            }

            // 3.2) Shift the last three rows according to its row number
            std::vector<std::vector<unsigned char>> temp(4, std::vector<unsigned char>(4));

            for(int i = 0; i < 4; i++) {
                for(int ii = 0; ii < 4; ii++) {
                    
                    int shiftIndex = ii + i;
                    if(ii + i == 4) shiftIndex = 0;
                    else if(ii + i == 5) shiftIndex = 1;
                    else if(ii + i == 6) shiftIndex = 2;

                    temp[i][ii] = messageBlocks[blockIndex][i][shiftIndex];
                }
            }

            messageBlocks[blockIndex] = temp;

            // 3.3) Rijndael MixColumns
            std::vector<std::vector<unsigned char>> tmp(4, std::vector<unsigned char>(4));
            
            for(int column = 0; column < 4; column++) {
                tmp[0][column] = mul2[messageBlocks[blockIndex][0][column]]^mul3[messageBlocks[blockIndex][1][column]]^messageBlocks[blockIndex][2][column]^messageBlocks[blockIndex][3][column];
                tmp[1][column] = messageBlocks[blockIndex][0][column]^mul2[messageBlocks[blockIndex][1][column]]^mul3[messageBlocks[blockIndex][2][column]]^messageBlocks[blockIndex][3][column];
                tmp[2][column] = messageBlocks[blockIndex][0][column]^messageBlocks[blockIndex][1][column]^mul2[messageBlocks[blockIndex][2][column]]^mul3[messageBlocks[blockIndex][3][column]];
                tmp[3][column] = mul3[messageBlocks[blockIndex][0][column]]^messageBlocks[blockIndex][1][column]^messageBlocks[blockIndex][2][column]^mul2[messageBlocks[blockIndex][3][column]];
            }

            messageBlocks[blockIndex] = tmp;

            // 3.4) XoR messageBlock with roundkeys
            for(int i = 0; i < 4; i++) {
                for(int ii = 0; ii < 4; ii++) messageBlocks[blockIndex][i][ii] ^= keyRounds[round][i][ii];
            }

        }

        // 4) Do last round but without MixColumns operation
        // 4.1) Get subbytes from S-box
        for(int i = 0; i < 4; i++) {
            for(int ii = 0; ii < 4; ii++) messageBlocks[blockIndex][i][ii] = Sbox[messageBlocks[blockIndex][i][ii]];
        }

        // 4.2) Shift the last three rows left according to its row number
        for(int i = 0; i < 4; i++) {
            std::vector<unsigned char> temp(4);

            for(int ii = 0; ii < 4; ii++) {

                int shiftIndex = ii + i;
                if(ii + i == 4) shiftIndex = 0;
                else if(ii + i == 5) shiftIndex = 1;
                else if(ii + i == 6) shiftIndex = 2;


                temp[ii] = messageBlocks[blockIndex][i][shiftIndex];
            }
            
            messageBlocks[blockIndex][i] = temp;
        }

        // 4.3) XoR messageBlock with roundkeys
        for(int i = 0; i < 4; i++) {
            for(int ii = 0; ii < 4; ii++) messageBlocks[blockIndex][i][ii] ^= keyRounds[10][i][ii];
        }


        // Add cipherblocks to ciphertext
        for(int i = 0; i < 4; i++) {
            for(int ii = 0; ii < 4; ii++, decIndex++) {
                decCipherBlock[decIndex] = int(messageBlocks[blockIndex][i][ii]);
            }
        }
        
    }

    
    // Separate ciphertext from IV with ::
    decCipherBlock[decIndex] = 58; 
    decCipherBlock[decIndex + 1] = 58;
    decIndex += 2;

    // Add IV
    for(int i = 0; i < 4; i++) for(int ii = 0; ii < 4; ii++, decIndex++) decCipherBlock[decIndex] = IV[i][ii];

    return encode(decCipherBlock);
}  


//Function that decrypts the message
std::string decrypt(std::vector<std::vector<std::vector<unsigned char>>> keyRounds, std::string cipherText) {

    std::string decryptedMessage;
    std::vector<int> bytesTotal = decode(cipherText);

    int splitIndex = 0;
    while(bytesTotal[splitIndex] != 58 || bytesTotal[splitIndex + 1] != 58) splitIndex++;

    std::vector<std::vector<std::vector<unsigned char>>> cipherBlocks(splitIndex / 16, std::vector<std::vector<unsigned char>>(4, std::vector<unsigned char>(4)));
    unsigned char IV[4][4];

    //Seperate message bytes from ciphertext
    for(int i = 0, y = 0; i < cipherBlocks.size(); i++) {
        for(int ii = 0; ii < 4; ii++) {
            for(int iii = 0; iii < 4 && y < splitIndex; iii++, y++) cipherBlocks[i][ii][iii] = bytesTotal[y];
        }
    }

    //Seperate IV bytes from ciphertext
    for(int i = 0, y = splitIndex + 2; i < 4; i++){
        for(int ii = 0; ii < 4 && y < bytesTotal.size(); ii++, y++) IV[i][ii] = bytesTotal[y];
    }

    //Repeat this process for all cipher blocks
    for(int blockIndex = 0; blockIndex < cipherBlocks.size(); blockIndex++) {
        
        std::vector<std::vector<unsigned char>> currentBlock = cipherBlocks[blockIndex];
        // 1) First round
        // 1.1) XoR cipherBlock with roundKey 10
        for(int i = 0; i < 4; i++) for(int ii = 0; ii < 4; ii++) currentBlock[i][ii] ^= keyRounds[10][i][ii];

        // 1.2) Shift the last three round right according to its row number
        for(int i = 0; i < 4; i++) {
            unsigned char temp[4];

            for(int ii = 0; ii < 4; ii++) {

                int shiftIndex = ii - i;
                if(ii - i == -1) shiftIndex = 3;
                if(ii - i == -2) shiftIndex = 2;
                if(ii - i == -3) shiftIndex = 1;

                temp[ii] = currentBlock[i][shiftIndex];
            }

            for(int ii = 0; ii < 4; ii++) currentBlock[i][ii] = temp[ii];
        }

        // 1.3) Backwards S-box subbytes
        for(int i = 0; i < 4; i++) {
            for(int ii = 0; ii < 4; ii++) {
                int sVal = 0;
                while(currentBlock[i][ii] != Sbox[sVal]) sVal++;
                currentBlock[i][ii] = sVal;
            }
        }


        // 2) Repeat the following for 9 times
        for(int round = 9; round > 0; round--) {
            
            // 2.1) Xor cipherBlock with roundkey
            for(int i = 0; i < 4; i++) for(int ii = 0; ii < 4; ii++) currentBlock[i][ii] ^= keyRounds[round][i][ii];

            // 2.2) Reverse the Rijndael MixColumns operation 
            unsigned char tmp[4][4];
            
            for(int column = 0; column < 4; column++) {
                tmp[0][column] = mul14[currentBlock[0][column]]^mul11[currentBlock[1][column]]^mul13[currentBlock[2][column]]^mul9[currentBlock[3][column]];
                tmp[1][column] = mul9[currentBlock[0][column]]^mul14[currentBlock[1][column]]^mul11[currentBlock[2][column]]^mul13[currentBlock[3][column]];
                tmp[2][column] = mul13[currentBlock[0][column]]^mul9[currentBlock[1][column]]^mul14[currentBlock[2][column]]^mul11[currentBlock[3][column]];
                tmp[3][column] = mul11[currentBlock[0][column]]^mul13[currentBlock[1][column]]^mul9[currentBlock[2][column]]^mul14[currentBlock[3][column]];
            }

            for(int i = 0; i < 4; i++) for(int ii = 0; ii < 4; ii++) currentBlock[i][ii] = tmp[i][ii];
            
            // 2.3) Shift last three rows to right 
            for(int i = 0; i < 4; i++) {
                std::vector<int> temp(4);

                for(int ii = 0; ii < 4; ii++) {

                    int shiftIndex = ii - i;
                    if(ii - i == -1) shiftIndex = 3;
                    if(ii - i == -2) shiftIndex = 2;
                    if(ii - i == -3) shiftIndex = 1;

                    temp[ii] = currentBlock[i][shiftIndex];
                }
                
                for(int ii = 0; ii < 4; ii++) currentBlock[i][ii] = temp[ii];
            }

            // 2.4) Backwards S-box subbytes
            for(int i = 0; i < 4; i++) {
                for(int ii = 0; ii < 4; ii++) {
                    int sVal = 0;
                    while(currentBlock[i][ii] != Sbox[sVal]) sVal++;
                    currentBlock[i][ii] = sVal;
                }
            }
        }
        // 3) XoR cipherblock with roundkey 0
        for(int i = 0; i < 4; i++) {
            for(int ii = 0; ii < 4; ii++) currentBlock[i][ii] ^= keyRounds[0][i][ii];
        }

        // 4) XoR cipherBlock with IV
        for(int i = 0; i < 4; i++) for(int ii = 0; ii < 4; ii++) {
            if(blockIndex == 0) currentBlock[i][ii] ^= IV[i][ii];
            else currentBlock[i][ii] ^= cipherBlocks[blockIndex - 1][i][ii];
        }
        
        // Add to decrypted message
        for(int i = 0; i < 4; i++) {
            for(int ii = 0; ii < 4; ii++) decryptedMessage += char(currentBlock[i][ii]);
        }

    }
    return decryptedMessage;

}
